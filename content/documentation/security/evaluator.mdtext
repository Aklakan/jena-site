Title: Jena Security - SecurityEvaluator implementation

## Overview

The SecurityEvaluator interface defines the access control operations. It provides the interface between the 
authentication (answers the question: "who are you?") and the authorization (answers the question: "what can you
do?"), as such it provides access to the current principal (user).  The javadocs contain detailed
requirements for implementations of the SecurityEvaluator interface, short notes are provided below.

**NOTE** The security system caches intermediate results and will only call the evaluator if the answer is not
already in the cache.  There is little or advantage to implementing caching in the SecurityEvaluator itself.

### Actions

Principals may perform Create, Read, Action or Delete operations on 
secured resources.  These operations are defined in the `Action` enum in the SecurtyEvaluator interface.

### SecNode

The security node is a class that tracks the type and node value.  SecNodes are one of the four enumerated Types 
found in the SecNodes class:

- **URI**  A URI node.
- **Literal**  A Literal node.
- **Anonymous**  An anonymous node.  Also called a "blank" node.
- **Any** Any node.  This is a special case used for wild card matching.

SecNode defines three static nodes:

- `SecNode.ANY = new SecNode(Type.Any, "any")`  Matches any node in the security system.
- `SecNode.VARIABLE = new SecNode(Type.Any, "variable")` Indicates a variable in the triple.
- `SecNode.FUTURE = new SecNode(Type.Anonymous, "")` This is an anonymous node that will be created in the future.


### SecTriple

The security triple is a class that provides a triple of SecNode objects.  SecTriple also defines a single static
triple:

- `SecTriple.ANY` = new SecTriple(SecNode.ANY, SeccNode.ANY, SecNode.ANY)` Matches any SecTriple.

### Evaluator Methods
 
    public boolean evaluate( Action action, SecNode graphIRI );
Determine if the action is permitted within the graph.

    public boolean evaluate( Action action, SecNode graphIRI, SecTriple triple );
Determine if the action is allowed on the triple within the graph.

    public boolean evaluate( Set<Action> actions, SecNode graphIRI );
Determine if all actions are allowed on the graph.
    
    public boolean evaluate( Set<Action> actions, SecNode graphIRI, SecTriple triple );            
Determine if all the actions are allowed on the triple within the graph.            

    public boolean evaluateAny( Set<Action> actions, SecNode graphIRI );
Determine if any of the actions are allowed on the graph.
   
    public boolean evaluateAny( Set<Action> actions, SecNode graphIRI, SecTriple triple );
Determine if any of the actions are allowed on the triple within the graph.

    public boolean evaluateUpdate( SecNode graphIRI, SecTriple from, SecTriple to );
Determine if the user is allowed to update the "from" triple to the "to" triple.            

    public Principal getPrincipal();   
returns the current principal or null if there is no current principal.    

## Sample Implementation

This sample is for a graph that contains a set of messages, access to the messages are limited to 
principals that the messages are to or from.  Any triple that is not a message is not affected. This 
implementation simply has a `setPrincipal(String name)` method.  A real implementation would request the
user principal or name from the authentication system.  This implementation also requires access to the underlying
model to determine if the user has access, however, that is not a requirement of the SecurityEvaluator in general.
Determining access from the information provided is an exercise for the implementer. 

<!-- language: lang-java -->
    
    public class ExampleEvaluator implements SecurityEvaluator {
        
        private Principal principal;
        private Model model;
        private RDFNode msgType = ResourceFactory.createResource( "http://example.com/msg" );
        private Property pTo = ResourceFactory.createProperty( "http://example.com/to" );
        private Property pFrom = ResourceFactory.createProperty( "http://example.com/from" );
        
        /**
         * 
         * @param model The graph we are going to evaluate against.
         */
        public ExampleEvaluator( Model model )
        {
            this.model = model;
        }
        
        @Override
        public boolean evaluate(Action action, SecNode graphIRI) {
            // we allow any action on a graph.
            return true;
        }
    
        private boolean evaluate( Resource r )
        {
            // a message is only available to sender or recipient
            if (r.hasProperty( RDF.type, msgType ))
            {
                return r.hasProperty( pTo, principal.getName() ) ||
                        r.hasProperty( pFrom, principal.getName());
            }
            return true;    
        }
        
        private boolean evaluate( SecNode node )
        {
            if (node.equals( SecNode.ANY )) {
                return false;  // all wild cards are false
            }
            
            if (node.getType().equals( SecNode.Type.URI)) {
                Resource r = model.createResource( node.getValue() );
                return evaluate( r );
            }
            else if (node.getType().equals( SecNode.Type.Anonymous)) {
                Resource r = model.getRDFNode( NodeFactory.createAnon( new AnonId( node.getValue()) ) ).asResource();
                return evaluate( r );
            }
            else
            {
                return true;
            }
    
        }
        
        private boolean evaluate( SecTriple triple ) {
            return evaluate( triple.getSubject()) &&
                    evaluate( triple.getObject()) &&
                    evaluate( triple.getPredicate());
        }
        
        @Override
        public boolean evaluate(Action action, SecNode graphIRI, SecTriple triple) {
            return evaluate( triple );
        }
    
        @Override
        public boolean evaluate(Set<Action> actions, SecNode graphIRI) {
            return true;
        }
    
        @Override
        public boolean evaluate(Set<Action> actions, SecNode graphIRI,
                SecTriple triple) {
            return evaluate( triple );
        }
    
        @Override
        public boolean evaluateAny(Set<Action> actions, SecNode graphIRI) {
            return true;
        }
    
        @Override
        public boolean evaluateAny(Set<Action> actions, SecNode graphIRI,
                SecTriple triple) {
            return evaluate( triple );
        }
    
        @Override
        public boolean evaluateUpdate(SecNode graphIRI, SecTriple from, SecTriple to) {
            return evaluate( from ) && evaluate( to );
        }
    
        public void setPrincipal( String userName )
        {
            if (userName == null)
            {
                principal = null;
            }
            principal = new BasicUserPrincipal( userName );
        }
        @Override
        public Principal getPrincipal() {
            return principal;
        }
    
    }
